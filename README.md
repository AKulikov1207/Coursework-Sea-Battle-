# Курсовая работа Разработка игры "Морской бой".
### Программный модуль должен обеспечивать выбор уровня сложности. Алгоритм программы должен позволять изменять карту кораблей. Реализовать обработку исключительных ситуаций.

## Введение
Программа «Морской бой» – чисто игровая программа, предназначена для удовлетворения игровых потребностей пользователя. Она требует использования мыши, так как только с ее помощью пользователь может размещать на игровом поле корабли и «стрелять» по кораблям противника.
Постановка задачи: Разработать программу, реализующую игру «Морской бой» в режиме пользователь – компьютер. В процессе реализации данной задачи использовать основные свойства объектно-ориентированного программирования (в обязательном порядке создать несколько классов (свойство инкапсуляции), которые будут взаимодействовать между собой и, если будет необходимо, использовать также другие свойства ООП).
Цель: Достичь реализации данной задачи наиболее оптимальными методами и с минимальной тратой ресурсов.
Возможности программы: С помощью данной программы пользователь может насладиться игрой «Морской бой» в режиме пользователь-компьютер.

## Обоснование выбора программных средств для решения задачи
Для реализации своего проекта я буду использовать программное средство «C++ Builder». Данное программное обеспечение относится к линейке продуктов Embarcadero Technologies, включающих интегрированную среду разработки, редактор исходного кода, встроенный отладчик. Оно позволяет разрабатывать как консольные приложения, так и приложения с графическим интерфейсом.
«C++ Builder» имеет удобный и понятный интерфейс, это современная среда разработки, позволяющая работать с кодом без лишних трудностей.

## Описание предметной области
Предметная область данного проекта – игра «Морской бой». Она реализуется с помощью нажатий на клавиши мыши (размещение кораблей и выстрелы по кораблям противника, удачные попадания фиксируются желтым цветом).
Правила игры следующие: в поле 10х10 пользователь расставляет свои корабли (корабли не должны лежать друг на друге, стоять рядом, пересекаться). Точно так же компьютер на своем игровом поле расставляет свои корабли. Количество кораблей 10, а именно: один четырехпалубный (одна палуба соответствует одной клетке игрового поля), два трехпалубных, три двухпалубных и четыре однопалубных. После расстановки кораблей пользователь и компьютер поочередно «стреляют» по клеткам игрового поля противника. Если кому-либо из них удалось попасть во вражеский корабль, то, согласно правилам, ход не переходит к противнику (если игрок попал в корабль противника, то он имеет право еще одного выстрела) до следующего промаха. Победа достается тому, кто первым уничтожит все корабли противника.

## Описание классов
С целью более удобного проектирования, настройки, и разделения отдельных исполняемых операций, программа построена на классах, которые взаимодействуют между собой. Использование классов делает улучшенной понимание кода, а значит настройку и последующую модификацию исходного кода программы.
В данной программе четко прослеживаются группы функций, которые из-за выполняемых ними операций стоит объединить в классы. Проанализировав предметную область программы можно выделить следующие классы:
Класс Flot – класс, который содержит данные о кораблях (количество кораблей, поле на котором следует размещать корабли и т.д.);
Класс AI – так называемый класс искусственного интеллекта, размещает корабли противника;
Класс Referee – наследник класса AI, который проверяет состояние кораблей и флотов пользователя и компьютера;
Класс HandersOfEvents – наследник класса Referee. Это единственный класс в данной программе, который взаимодействует с формой напрямую.
Также в программе используется структура Ship, которая содержит данные о количестве палуб корабля, расположении частей корабля, следит за состоянием корабля в целом.

 // класс ***Flot***
class Flot {
public:
  int i, j, n;          // переменные, используемые в циклах
  bool destroy;   // флаг, проверяющий наличие флота
  TImage *Im;   // поле, на котором мы рисуем
  Ship ship[10]; // количество кораблей
  Flot (TImage *I) {
    destroy = false;
    Im = I;
    n = 1;
    for (i = 0; i < 10; i++) {
      if (i < 6) n = 2;
      if (i < 3) n = 3;
      if (i == 0) n = 4;
      ship[i].destroy = false;
      ship[i].col_deck = n;
      ship[i].decks = new bool[n];
      ship[i].desp_of_part = new TPoint[n];
    }
  }
  int GetStatus();
};

 // класс ***AI***
class AI {
public:
  int Generation (Flot *CPU, int col_ship, int col_deck); // размещение кораблей противника
};

 // класс ***Referee***
class Referee: public AI {
public:
  int i, j, target_player, target_CPU;
  bool net1 [10] [10], net2 [10] [10], game_over;
  Flot *player, *CPU;
  Referee() {
    for (i = 0; i < 10; i++)
      for (j = 0; j < 10; j++) {
        net1 [i] [j] = true;
        net2 [i] [j] = true;}
  game_over = false;
  target_player = 0;
  target_CPU = 0;}
  int GoChecking (int x, int y, int n);            // запуск функции проверки
  int Check (bool net[10] [10], int x, int y); // проверка попадания в старую или новую ячейку
  int GoScaning (int x, int y, int n);            // запуск функции сканирования
  int Scan (Flot *fl, int x, int y); // сканирование (проверка) попадания в корабль
  int Miss (int x, int y, int n); // отмечание ячейки в которую попали (но не в корабль)
  int EndRaund (int n);             // конец игры
};

 // класс ***HandlersOfEvents***
class HandlersOfEvents: public Referee {
public:
  bool play;
  int col_deck, col_ship, i, j, k;
  HandlersOfEvents (TImage *Im1, TImage *Im2) {
    play = false;
    col_deck = 4;  col_ship = 1;
    player = new Flot(Im1);
    CPU = new Flot(Im2);
  }
  int Play (TImage *Im1, TImage *Im2);
  int Move();
  int Desposition(int x, int y, TMouseButton Button); // размещение кораблей
  int Draw (String key, int x, int y, int n); // рисование
  int ShootPlayer (int x, int y, int n);         // выстрел игрока
  int Shoot (int x, int y);                            // выстрел компьютера
};

 // структура ***Ship***
struct Ship {
  bool destroy; // флаг уничтожения корабля
  int col_deck; // количество палуб
  bool *decks; // массив палуб
  TPoint *desp_of_part; // расположение частей (палуб) корабля
};

## Руководство пользователя для прикладной программы
После того, как игра запущенна пользователь должен нажать кнопку «Начать» и приступить к расстановке своих кораблей. Левой кнопкой мыши корабли ставятся горизонтально, правой кнопкой вертикально. Затем начинается «бой». Пользователь нажимает на клетки поля соперника делая «выстрел». Бой с противником продолжается до полной победы, т.е. пока не будут уничтожены все 10 кораблей одного из противников.

Если первым свои корабли потерял компьютер, игроку выводится сообщение о победе
 
рис. 5. Сообщение о победе

Если первым свои корабли потерял игрок, ему выводится сообщение о проигрыше
 
рис. 6. Сообщение о проигрыше

В начале игры выводится приглашение к расстановке кораблей:
 
рис. 7. Расстановка кораблей

Если игрок выполнил недопустимое действие (например, попытался «наложить» корабль на корабль) ему будет выведено предупреждающее сообщение о его ошибке.
 

Если расстановка кораблей закончилась выводится приглашение к началу игры
 
рис. 8. Начало игры

В случае промаха игроку выводится сообщение о промахе
 
рис. 9. Сообщение о промахе

В случае попадания игроку выводится сообщение о попадании
 
рис. 10 Сообщение о попадании

В случае попадания в ячейку, которая уже обстреляна, игроку выводится сообщение с предложением выстрелить ещё раз
 
рис. 11. Сообщение о выстреле в обстрелянную ячейку

В случае уничтожения корабля игроку выводится сообщение об этом
 
рис. 12 Сообщение об уничтожении корабля

В игре реализованы три уровня сложности, выбрать которые можно с помощью представленного списка в левом нижнем углу. 

1 четырёхпалубник, 2 трёхпалубника, 3 двухпалубника, 4 однопалубника
 
рис. 13. Уровень 1

2 четырёхпалубника, 3 трёхпалубника, 3 двухпалубника, 4 однопалубника
 
рис. 14. Уровень 2

2 четырёхпалубника, 3 трёхпалубника, 5 двухпалубников, 5 однопалубников
 
рис. 15. Уровень 3


## Описание использованных средств языка программирования
Библиотека визуальных компонентов (VCL) позволяет разработчикам быстро разрабатывать приложения и пользовательские интерфейсы для Microsoft Windows:
#include <vcl.h>

Макрос System::USEFORM, для подключения ресурса указанной в параметре формы:
USEFORM("UShipBattle.cpp", Form1);

WINAPI – это соглашение о вызове, которое определяет, как функция получает параметры от вызывающего объекта:
int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int) {}

Макрос, инициализирующий генератор случайных чисел некоторой случайной величи¬ной:
randomize();


## Выводы
В процессе выполнения данного курсового проекта были закреплены знания по использованию классов и использованию основ объектно-ориентированного программирования.
Конец игры предусмотрен в двух случаях: победа пользователя или победа компьютера. Также в процессе написания программы были рассмотрены все варианты некорректной работы программы, например: не размещает ли компьютер и пользователь корабли в соседних клетках, не ставит ли он корабли только в углах игрового поля, не накладываются ли корабли один на другой. Также проверяется соответствие количества кораблей и палуб на них (1 четырехпалубный, 2 трехпалубных, 3 двухпалубных, 4 однопалубных). Все вышеописанные неполадки были обнаружены и успешно устранены. Реализованы три уровня сложности.
Во время написания программы я получил навыки по использованию компонентов среды программирования «С++ Builder».
Также при написании данного курсового проекта я закрепил свои знания в области написания объектно-ориентированных программ, содержащих взаимодействующие классы. Были получены новые знания о создании классов и работе с ними. Благодаря работе над программой были закреплены знания распределения обязанностей между классами.
